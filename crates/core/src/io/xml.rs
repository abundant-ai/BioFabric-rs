//! BioFabric XML session format (.bif).
//!
//! The XML format preserves a complete BioFabric session: network data,
//! layout state, annotations, display options, and alignment data.
//! This is the native save/load format for BioFabric sessions.
//!
//! ## What is saved
//!
//! | Section              | Contents                                    |
//! |----------------------|---------------------------------------------|
//! | Colors               | Brighter (node) and darker (link) palettes  |
//! | Display options      | Shadow toggle, label settings, colors, etc.  |
//! | Nodes                | Row, column span, drain zones, color key    |
//! | Link groups          | Ordered list of relation types (if grouped) |
//! | Links                | Column, shadow, direction, color key        |
//! | Annotations          | Node, link, shadow-link annotation sets     |
//! | Plugin data          | Empty (reserved for plugins)                |
//!
//! ## References
//!
//! - Java: `org.systemsbiology.biofabric.io.FabricFactory` (XML reader)
//! - Java: `org.systemsbiology.biofabric.model.BioFabricNetwork` (XML writer)
//! - Java: `org.systemsbiology.biofabric.parser.SUParser` (SAX parser)

use super::session::Session;
use super::ParseError;
use crate::layout::result::{LinkLayout, NetworkLayout, NodeLayout};
use crate::model::{Annotation, AnnotationSet, Link, Network, Node, NodeId};
use crate::render::color::{build_gene_colors, FabricColor, GENE_COLOR_NAMES};
use crate::render::display_options::DisplayOptions;
use indexmap::IndexMap;
use std::collections::HashMap;
use std::io::{BufReader, Read, Write};
use std::path::Path;

// ===========================================================================
// Constants
// ===========================================================================

/// Java default for node lighter level.
const JAVA_DEFAULT_NODE_LIGHTER: f64 = 0.43;
/// Java default for link darker level.
const JAVA_DEFAULT_LINK_DARKER: f64 = 0.43;
/// Java default for min drain zone.
const JAVA_DEFAULT_MIN_DRAIN_ZONE: i32 = 1;

/// Indices of gene colors that are NOT brightened (kept as-is for node colors).
///
/// Java checks `nc.name.indexOf("Gold")`, `nc.name.indexOf("Dark Wheat")`,
/// and `nc.name.indexOf("Pale Goldenrod")` — these match:
/// - Index 16: "Gold" (EX-yellow)
/// - Index 24: "Dark Wheat" (EX-pale-yellow orange)
/// - Index 28: "Pale Goldenrod" (EX-pale-yellow-green) — also contains "Gold"
const NO_BRIGHTEN_INDICES: [usize; 3] = [16, 24, 28];

/// Order in which Java's `HashMap<String, Color>` iterates the 32 gene color
/// keys.  Java's `FabricColorGenerator.writeColorsForType()` iterates
/// `brighter_` and `darker_` — both `HashMap`s — so the XML output order is
/// determined by `String.hashCode()` bucket placement.  This constant maps
/// output position (0–31) to our Rust gene-color index.
///
/// Derived empirically from the golden BIF files generated by Java BioFabric.
const JAVA_HASHMAP_COLOR_ORDER: [usize; 32] = [
    16, // EX-yellow
    17, // EX-purple
    14, // EX-magenta
    27, // EX-pale-cyan
     9, // EX-dark-yellow-green
    29, // EX-pale-purple
    19, // EX-dark-red
    13, // EX-yellow-green
    21, // EX-pale-blue
    18, // EX-dark-purple
    23, // EX-pale-blue-magenta
    26, // EX-pale-red
     0, // EX-blue
    11, // EX-dark-green
    20, // EX-pale-green
     3, // EX-red
     6, // EX-cyan
    24, // EX-pale-yellow orange
    30, // EX-pale-magenta
    31, // EX-pale-red-orange
    12, // EX-blue-magenta
     1, // EX-orange
     4, // EX-dark-orange
    15, // EX-green
    25, // EX-medium-magenta
    10, // EX-dark-magenta
     7, // EX-yellow-orange
    28, // EX-pale-yellow-green
     5, // EX-dark-gray-purple
     2, // EX-dark-cyan
    22, // EX-dark-tan
     8, // EX-pure-blue
];

// ===========================================================================
// XML Writer — Public API
// ===========================================================================

/// Write a complete session to a BioFabric XML file.
pub fn write_session(session: &Session, path: &Path) -> Result<(), ParseError> {
    let file = std::fs::File::create(path)?;
    let writer = std::io::BufWriter::new(file);
    write_session_writer(session, writer)
}

/// Write a session to a writer.
pub fn write_session_writer<W: Write>(
    session: &Session,
    mut w: W,
) -> Result<(), ParseError> {
    let layout = session
        .layout
        .as_ref()
        .expect("session must have a layout for BIF export");
    let network = &session.network;
    let display = &session.display_options;

    // -- Build helper maps --

    // NID map: NodeId → sequential integer
    // Java's UniqueLabeller assigns nids in insertion order (the order nodes
    // are first encountered during network building). Since Network uses an
    // IndexMap that preserves insertion order, node_ids() already yields
    // nodes in the correct order — no sorting needed.
    let nid_map: IndexMap<NodeId, usize> = network
        .node_ids()
        .cloned()
        .enumerate()
        .map(|(i, id)| (id, i))
        .collect();

    // Row → NodeId map
    let row_to_node: Vec<NodeId> = {
        let mut entries: Vec<_> = layout.iter_nodes().collect();
        entries.sort_by_key(|(_, nl)| nl.row);
        entries.into_iter().map(|(id, _)| id.clone()).collect()
    };

    // Directed map: (source, target, relation) → directed
    // -- Build color palettes --
    let gene_colors = build_gene_colors();
    let (brighter, darker) = build_color_maps(&gene_colors, display);

    // -- Compute drain zones --
    let (plain_drain_zones, shadow_drain_zones) =
        compute_drain_zones(layout, &row_to_node);

    // -- Write XML --
    writeln!(w, "<BioFabric>")?;

    // 1. Colors
    write_colors(&mut w, &brighter, &darker)?;

    // 2. Display options
    write_display_options(&mut w, display)?;

    // 3. Nodes (sorted by row)
    write_nodes(
        &mut w,
        layout,
        &nid_map,
        &plain_drain_zones,
        &shadow_drain_zones,
    )?;

    // 4. Link groups (if non-empty)
    write_link_groups(&mut w, layout)?;

    // 5. Links (sorted by shadow column)
    write_links(&mut w, layout, &nid_map, &row_to_node)?;

    // 6. Annotations
    // Java mapping:
    //   <linkAnnotations>       → non-shadow column ranges (linkAnnots_)
    //   <shadowLinkAnnotations> → shadow column ranges (fullLinkAnnots_)
    write_annotation_section(&mut w, "nodeAnnotations", &layout.node_annotations)?;
    write_annotation_section(&mut w, "linkAnnotations", &layout.link_annotations_no_shadows)?;
    write_annotation_section(
        &mut w,
        "shadowLinkAnnotations",
        &layout.link_annotations,
    )?;

    // 7. Plugin data
    writeln!(w, "  <plugInDataSets>")?;
    for line in &session.plugin_data_lines {
        writeln!(w, "{}", line)?;
    }
    writeln!(w, "  </plugInDataSets>")?;

    writeln!(w, "</BioFabric>")?;

    Ok(())
}

/// Write a session to a String (for testing).
pub fn write_session_string(session: &Session) -> Result<String, ParseError> {
    let mut buf = Vec::new();
    write_session_writer(session, &mut buf)?;
    Ok(String::from_utf8(buf).expect("XML output should be valid UTF-8"))
}

// ===========================================================================
// XML Writer — Internal helpers
// ===========================================================================

/// Escape XML special characters (matching Java CharacterEntityMapper.mapEntities).
///
/// Java's mapEntities with doSpaces=false escapes: & < > "
/// and converts non-ASCII chars > 127 to &#xHHHH; entities.
///
/// NOTE: Java has a subtle bug where `&` is replaced AFTER `"`, `<`, `>`,
/// which can cause double-escaping if both `&` and one of those characters
/// are present. In practice this never happens with BioFabric data.
/// We implement standard XML escaping (& first) which produces identical
/// output for all practical inputs.
fn xml_escape(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    for ch in s.chars() {
        match ch {
            '&' => result.push_str("&amp;"),
            '<' => result.push_str("&lt;"),
            '>' => result.push_str("&gt;"),
            '"' => result.push_str("&quot;"),
            c if c as u32 > 127 => {
                let code = c as u32;
                if code < 0x1000 {
                    result.push_str(&format!("&#x0{:x};", code));
                } else {
                    result.push_str(&format!("&#x{:x};", code));
                }
            }
            c => result.push(c),
        }
    }
    result
}

/// Format a Java-style double value.
///
/// Java's `Double.toString()` always includes a decimal point for whole numbers
/// (e.g., `0.0`, `1.0`). Rust's default `Display` strips it (e.g., `0`, `1`).
fn format_java_double(v: f64) -> String {
    let s = format!("{}", v);
    if s.contains('.') {
        s
    } else {
        format!("{}.0", s)
    }
}

/// Build the brighter (node) and darker (link) color maps.
///
/// Returns (brighter, darker) as vectors of (key, FabricColor) in gene color order.
///
/// **Important:** The color maps are always computed using the default lighter/darker
/// levels (0.43/0.43), regardless of the current display options. This matches Java's
/// behavior where `FabricColorGenerator.newColorModel()` is called once at startup
/// with the default `FabricDisplayOptions`, and subsequent changes to
/// `nodeLighterLevel_` / `linkDarkerLevel_` do not trigger a recomputation of the
/// brighter/darker color maps. The display options values are written to the
/// `<displayOptions>` XML element but do NOT affect the `<colors>` section.
fn build_color_maps(
    gene_colors: &[FabricColor; 32],
    _display: &DisplayOptions,
) -> (Vec<(&'static str, FabricColor)>, Vec<(&'static str, FabricColor)>) {
    let light = JAVA_DEFAULT_NODE_LIGHTER + 1.0;
    let dark = 1.0 / (JAVA_DEFAULT_LINK_DARKER + 1.0);

    let mut brighter = Vec::with_capacity(32);
    let mut darker = Vec::with_capacity(32);

    // Iterate in Java HashMap iteration order so the XML output matches
    // the golden files byte-for-byte.
    for &i in &JAVA_HASHMAP_COLOR_ORDER {
        let key = GENE_COLOR_NAMES[i].key;
        let base = gene_colors[i];

        // Brighter: apply light factor unless this is a no-brighten color
        let bright = if NO_BRIGHTEN_INDICES.contains(&i) {
            base
        } else {
            FabricColor::rgb(
                (base.r as f64 * light).round().min(255.0) as u8,
                (base.g as f64 * light).round().min(255.0) as u8,
                (base.b as f64 * light).round().min(255.0) as u8,
            )
        };

        // Darker: always apply dark factor
        let dark_color = FabricColor::rgb(
            (base.r as f64 * dark).round().min(255.0) as u8,
            (base.g as f64 * dark).round().min(255.0) as u8,
            (base.b as f64 * dark).round().min(255.0) as u8,
        );

        brighter.push((key, bright));
        darker.push((key, dark_color));
    }

    (brighter, darker)
}

/// Write the `<colors>` section.
fn write_colors<W: Write>(
    w: &mut W,
    brighter: &[(&str, FabricColor)],
    darker: &[(&str, FabricColor)],
) -> Result<(), ParseError> {
    writeln!(w, "  <colors>")?;
    write_color_set(w, "nodes", brighter)?;
    write_color_set(w, "links", darker)?;
    writeln!(w, "  </colors>")?;
    Ok(())
}

/// Write a single `<colorSet>`.
fn write_color_set<W: Write>(
    w: &mut W,
    usage: &str,
    colors: &[(&str, FabricColor)],
) -> Result<(), ParseError> {
    writeln!(w, "    <colorSet usage=\"{}\">", usage)?;
    for (key, c) in colors {
        writeln!(
            w,
            "      <color color=\"{}\" r=\"{}\" g=\"{}\" b=\"{}\" />",
            key, c.r, c.g, c.b
        )?;
    }
    writeln!(w, "    </colorSet>")?;
    Ok(())
}

/// Write the `<displayOptions />` element.
fn write_display_options<W: Write>(
    w: &mut W,
    display: &DisplayOptions,
) -> Result<(), ParseError> {
    // Collect attributes first to decide spacing
    let mut attrs = String::new();

    if display.shadows_explicit {
        attrs.push_str(&format!(
            "shadows=\"{}\" ",
            if display.show_shadows { "true" } else { "false" }
        ));
    }

    if (display.node_lighter_level - JAVA_DEFAULT_NODE_LIGHTER).abs() > 1e-12 {
        attrs.push_str(&format!(
            "nodeLight=\"{}\" ",
            format_java_double(display.node_lighter_level)
        ));
    }
    if (display.link_darker_level - JAVA_DEFAULT_LINK_DARKER).abs() > 1e-12 {
        attrs.push_str(&format!(
            "linkDark=\"{}\" ",
            format_java_double(display.link_darker_level)
        ));
    }
    if display.min_drain_zone != JAVA_DEFAULT_MIN_DRAIN_ZONE {
        attrs.push_str(&format!("minDrainZone=\"{}\" ", display.min_drain_zone));
    }

    if attrs.is_empty() {
        writeln!(w, "  <displayOptions />")?;
    } else {
        writeln!(w, "  <displayOptions {} />", attrs.trim_end())?;
    }
    Ok(())
}

/// Write the `<nodes>` section.
fn write_nodes<W: Write>(
    w: &mut W,
    layout: &NetworkLayout,
    nid_map: &IndexMap<NodeId, usize>,
    plain_drain_zones: &HashMap<NodeId, Vec<(usize, usize)>>,
    shadow_drain_zones: &HashMap<NodeId, Vec<(usize, usize)>>,
) -> Result<(), ParseError> {
    // Collect nodes sorted by row
    let mut nodes: Vec<(&NodeId, &NodeLayout)> = layout.iter_nodes().collect();
    nodes.sort_by_key(|(_, nl)| nl.row);

    writeln!(w, "  <nodes>")?;

    for (id, nl) in &nodes {
        // Use original NID from loaded BIF if available, otherwise compute from position
        let nid = nl.nid.unwrap_or_else(|| nid_map.get(*id).copied().unwrap_or(0));
        // Java assigns color based on the node's row index.
        // For extracted submodels, color_index stores the ORIGINAL row from the
        // full layout so the color is preserved after row compression.
        let color_key = GENE_COLOR_NAMES[nl.color_index % 32].key;

        // Java sets isolated nodes' columns to (columnCount - 1).
        // When columnCount is 0 (no links), this wraps to -1.
        // Detect isolated nodes via min > max (usize::MAX > 0 when no links assigned).
        let (min_col, max_col) = if nl.min_col_no_shadows > nl.max_col_no_shadows {
            let v = layout.column_count_no_shadows as isize - 1;
            (v.to_string(), v.to_string())
        } else {
            (nl.min_col_no_shadows.to_string(), nl.max_col_no_shadows.to_string())
        };
        let (min_col_sha, max_col_sha) = if nl.min_col > nl.max_col {
            let v = layout.column_count as isize - 1;
            (v.to_string(), v.to_string())
        } else {
            (nl.min_col.to_string(), nl.max_col.to_string())
        };

        // Include cluster attribute if the node has a cluster assignment
        let cluster_attr = layout
            .cluster_assignments
            .get(*id)
            .map(|c| format!(" cluster=\"{}\"", xml_escape(c)))
            .unwrap_or_default();

        write!(
            w,
            "    <node name=\"{}\" nid=\"{}\" row=\"{}\" minCol=\"{}\" maxCol=\"{}\" minColSha=\"{}\" maxColSha=\"{}\" color=\"{}\"{}>\n",
            xml_escape(&nl.name),
            nid,
            nl.row,
            min_col,
            max_col,
            min_col_sha,
            max_col_sha,
            color_key,
            cluster_attr,
        )?;

        // Plain drain zones — use pre-computed if available (e.g., from submodel extraction)
        let plain_dz = nl.plain_drain_zones.as_deref().or_else(|| plain_drain_zones.get(*id).map(|v| v.as_slice()));
        if let Some(zones) = plain_dz {
            if !zones.is_empty() {
                writeln!(w, "      <drainZones>")?;
                for (min_col, max_col) in zones {
                    writeln!(
                        w,
                        "        <drainZone minCol=\"{}\" maxCol=\"{}\" />",
                        min_col, max_col
                    )?;
                }
                writeln!(w, "      </drainZones>")?;
            } else {
                writeln!(w, "      <drainZones/>")?;
            }
        } else {
            writeln!(w, "      <drainZones/>")?;
        }

        // Shadow drain zones — use pre-computed if available
        let shadow_dz = nl.shadow_drain_zones.as_deref().or_else(|| shadow_drain_zones.get(*id).map(|v| v.as_slice()));
        if let Some(zones) = shadow_dz {
            if !zones.is_empty() {
                writeln!(w, "      <drainZonesShadow>")?;
                for (min_col, max_col) in zones {
                    writeln!(
                        w,
                        "        <drainZoneShadow minCol=\"{}\" maxCol=\"{}\" />",
                        min_col, max_col
                    )?;
                }
                writeln!(w, "      </drainZonesShadow>")?;
            } else {
                writeln!(w, "      <drainZonesShadow/>")?;
            }
        } else {
            writeln!(w, "      <drainZonesShadow/>")?;
        }

        writeln!(w, "    </node>")?;
    }

    writeln!(w, "  </nodes>")?;
    Ok(())
}

/// Write the `<linkGroups>` section (only if link group order is non-empty).
fn write_link_groups<W: Write>(
    w: &mut W,
    layout: &NetworkLayout,
) -> Result<(), ParseError> {
    if layout.link_group_order.is_empty() {
        return Ok(());
    }

    // Java's LayoutMode.getText() returns "perNode" or "perNetwork"
    let mode_text = if layout.layout_mode_text.is_empty() {
        "perNode"
    } else {
        &layout.layout_mode_text
    };
    let annots_text = if layout.link_group_annots.is_empty() {
        "true"
    } else {
        &layout.link_group_annots
    };
    writeln!(
        w,
        "  <linkGroups mode=\"{}\" annots=\"{}\">",
        mode_text, annots_text
    )?;
    for tag in &layout.link_group_order {
        writeln!(w, "    <linkGroup tag=\"{}\" />", xml_escape(tag))?;
    }
    writeln!(w, "  </linkGroups>")?;
    Ok(())
}

/// Write the `<links>` section.
///
/// Links are ordered by shadow column (ascending). For shadow links in Rust,
/// source/target are flipped relative to the original; we flip them back for
/// XML output to match Java's format.
fn write_links<W: Write>(
    w: &mut W,
    layout: &NetworkLayout,
    nid_map: &IndexMap<NodeId, usize>,
    _row_to_node: &[NodeId],
) -> Result<(), ParseError> {
    // Sort links by shadow column
    let mut links: Vec<&LinkLayout> = layout.iter_links().collect();
    links.sort_by_key(|ll| ll.column);

    writeln!(w, "  <links>")?;

    for ll in &links {
        // For shadow links, Rust flips source/target. Flip back for XML.
        // srcRow/trgRow are the actual rows of the source and target nodes.
        let (src_id, trg_id, src_row, trg_row) = if ll.is_shadow {
            (
                &ll.target,      // original source
                &ll.source,      // original target
                ll.target_row,   // original source's row
                ll.source_row,   // original target's row
            )
        } else {
            (
                &ll.source,
                &ll.target,
                ll.source_row,
                ll.target_row,
            )
        };

        // Use original NID from layout if available (for roundtrip fidelity)
        let src_nid = layout
            .get_node(src_id)
            .and_then(|nl| nl.nid)
            .unwrap_or_else(|| nid_map.get(src_id).copied().unwrap_or(0));
        let trg_nid = layout
            .get_node(trg_id)
            .and_then(|nl| nl.nid)
            .unwrap_or_else(|| nid_map.get(trg_id).copied().unwrap_or(0));

        // Use directed from LinkLayout if explicitly set, otherwise default to false
        // (matching Java's standard BioFabric behavior which writes directed="false").
        // SetLayout overrides this to true for its links.
        let directed = ll.directed.unwrap_or(false);

        // Java assigns link color based on the shadow column index.
        // For extracted submodels, color_index stores the ORIGINAL shadow column
        // from the full layout so the color is preserved after column compression.
        let color_key = GENE_COLOR_NAMES[ll.color_index % 32].key;

        write!(
            w,
            "    <link srcID=\"{}\" trgID=\"{}\" rel=\"{}\" directed=\"{}\" shadow=\"{}\"",
            src_nid,
            trg_nid,
            xml_escape(&ll.relation),
            directed,
            ll.is_shadow,
        )?;

        // column attribute only for non-shadow links
        if !ll.is_shadow {
            if let Some(ns_col) = ll.column_no_shadows {
                write!(w, " column=\"{}\"", ns_col)?;
            }
        }

        writeln!(
            w,
            " shadowCol=\"{}\" srcRow=\"{}\" trgRow=\"{}\" color=\"{}\" />",
            ll.column, src_row, trg_row, color_key,
        )?;
    }

    writeln!(w, "  </links>")?;
    Ok(())
}

/// Write an annotation section (nodeAnnotations, linkAnnotations, or shadowLinkAnnotations).
fn write_annotation_section<W: Write>(
    w: &mut W,
    tag_name: &str,
    annotations: &AnnotationSet,
) -> Result<(), ParseError> {
    writeln!(w, "  <{}>", tag_name)?;
    for annot in annotations.iter() {
        write!(
            w,
            "    <annot tag=\"{}\" start=\"{}\" end=\"{}\" layer=\"{}\"",
            xml_escape(&annot.name),
            annot.start,
            annot.end,
            annot.layer,
        )?;
        if !annot.color.is_empty() {
            write!(w, " color=\"{}\"", annot.color)?;
        }
        writeln!(w, " />")?;
    }
    writeln!(w, "  </{}>", tag_name)?;
    Ok(())
}

// ===========================================================================
// Drain Zone Computation
// ===========================================================================

/// A drain zone: contiguous column range where a node is the "main" endpoint.
///
/// For plain (non-shadow) drain zones: the main node is at the TOP (min row).
/// For shadow drain zones: the main node is at the TOP for non-shadow links,
/// and at the BOTTOM (max row) for shadow links.
fn compute_drain_zones(
    layout: &NetworkLayout,
    row_to_node: &[NodeId],
) -> (
    HashMap<NodeId, Vec<(usize, usize)>>,
    HashMap<NodeId, Vec<(usize, usize)>>,
) {
    // Plain drain zones: non-shadow links only, sorted by column_no_shadows
    let mut plain_links: Vec<&LinkLayout> =
        layout.links.iter().filter(|ll| !ll.is_shadow).collect();
    plain_links.sort_by_key(|ll| ll.column_no_shadows.unwrap_or(0));
    let plain = group_drain_zones(&plain_links, false, row_to_node);

    // Shadow drain zones: ALL links, sorted by shadow column
    let mut shadow_links: Vec<&LinkLayout> = layout.links.iter().collect();
    shadow_links.sort_by_key(|ll| ll.column);
    let shadow = group_drain_zones(&shadow_links, true, row_to_node);

    (plain, shadow)
}

/// Group consecutive links into drain zones.
///
/// The `for_shadow` flag controls which column and zone-node logic to use:
/// - `false`: plain mode — use `column_no_shadows`, zone node = top row node
/// - `true`: shadow mode — use `column`, zone node depends on shadow status
fn group_drain_zones(
    links: &[&LinkLayout],
    for_shadow: bool,
    row_to_node: &[NodeId],
) -> HashMap<NodeId, Vec<(usize, usize)>> {
    let mut result: HashMap<NodeId, Vec<(usize, usize)>> = HashMap::new();

    if links.is_empty() {
        return result;
    }

    /// Get the "zone node" for a link.
    ///
    /// - Non-shadow links: the node at the TOP (min row) — this is the node
    ///   whose horizontal line the link "drains from".
    /// - Shadow links: the node at the BOTTOM (max row).
    fn zone_node_id<'a>(ll: &LinkLayout, row_to_node: &'a [NodeId]) -> &'a NodeId {
        if ll.is_shadow {
            // Shadow links: zone node at bottom row
            let bottom = ll.source_row.max(ll.target_row);
            &row_to_node[bottom]
        } else {
            // Non-shadow: zone node at top row
            let top = ll.source_row.min(ll.target_row);
            &row_to_node[top]
        }
    }

    fn get_col(ll: &LinkLayout, for_shadow: bool) -> usize {
        if for_shadow {
            ll.column
        } else {
            ll.column_no_shadows.unwrap_or(0)
        }
    }

    let mut start_idx = 0;

    for i in 1..=links.len() {
        let flush = if i == links.len() {
            true
        } else {
            zone_node_id(links[i], row_to_node)
                != zone_node_id(links[start_idx], row_to_node)
        };

        if flush {
            let end_idx = i - 1;
            let start_col = get_col(links[start_idx], for_shadow);
            let end_col = get_col(links[end_idx], for_shadow);
            let node = zone_node_id(links[start_idx], row_to_node).clone();

            result.entry(node).or_default().push((start_col, end_col));

            if i < links.len() {
                start_idx = i;
            }
        }
    }

    result
}

// ===========================================================================
// XML Reader — Public API
// ===========================================================================

/// Read a BioFabric XML session file.
pub fn read_session(path: &Path) -> Result<Session, ParseError> {
    let file = std::fs::File::open(path)?;
    let reader = BufReader::new(file);
    read_session_reader(reader)
}

/// Read a BioFabric XML session from any reader.
pub fn read_session_reader<R: Read>(reader: BufReader<R>) -> Result<Session, ParseError> {
    let mut content = String::new();
    let mut reader = reader;
    reader.read_to_string(&mut content)?;
    parse_bif_xml(&content)
}

/// Read only the network data from a BioFabric XML file (ignoring layout).
pub fn read_network_only(path: &Path) -> Result<Network, ParseError> {
    let session = read_session(path)?;
    Ok(session.network)
}

// ===========================================================================
// XML Reader — Implementation
// ===========================================================================

/// Parse a BIF XML string into a Session.
fn parse_bif_xml(xml: &str) -> Result<Session, ParseError> {
    // We implement a simple line-based/regex-free parser that matches
    // the known BIF format structure. Since we control both the writer
    // and the Java golden generator, we can rely on the exact formatting.

    let mut network = Network::new();
    let mut layout = NetworkLayout::new();
    let mut display = DisplayOptions::default();

    // Parsing state
    let mut node_entries: Vec<ParsedNode> = Vec::new();
    let mut link_entries: Vec<ParsedLink> = Vec::new();
    let mut nid_to_name: HashMap<usize, String> = HashMap::new();
    let mut color_set_usage = String::new();
    let mut brighter_colors: Vec<(String, FabricColor)> = Vec::new();
    let mut darker_colors: Vec<(String, FabricColor)> = Vec::new();

    // Current parsing context
    let mut in_nodes = false;
    let mut in_links = false;
    let mut in_link_groups = false;
    let mut in_node_annots = false;
    let mut in_link_annots = false;
    let mut in_shadow_link_annots = false;
    let mut in_colors = false;
    let mut in_color_set = false;

    // Current node being parsed
    let mut current_node: Option<ParsedNode> = None;
    let mut in_drain_zones = false;
    let mut in_drain_zones_shadow = false;

    // Plugin data capture for roundtrip fidelity
    let mut in_plugin_data = false;
    let mut plugin_data_lines: Vec<String> = Vec::new();

    for line in xml.lines() {
        let trimmed = line.trim();

        if trimmed.is_empty()
            || trimmed == "<BioFabric>"
            || trimmed == "</BioFabric>"
        {
            continue;
        }

        // Capture plugin data verbatim for roundtrip
        if trimmed == "<plugInDataSets>" {
            in_plugin_data = true;
            continue;
        }
        if trimmed == "</plugInDataSets>" {
            in_plugin_data = false;
            continue;
        }
        if in_plugin_data {
            // Store the line with original indentation (relative to 4-space base)
            plugin_data_lines.push(line.to_string());
            continue;
        }

        // Colors section
        if trimmed == "<colors>" {
            in_colors = true;
            continue;
        }
        if trimmed == "</colors>" {
            in_colors = false;
            continue;
        }
        if in_colors && trimmed.starts_with("<colorSet ") {
            color_set_usage = extract_attr(trimmed, "usage").unwrap_or_default();
            in_color_set = true;
            continue;
        }
        if trimmed == "</colorSet>" {
            in_color_set = false;
            continue;
        }
        if in_color_set && trimmed.starts_with("<color ") {
            let key = extract_attr(trimmed, "color").unwrap_or_default();
            let r: u8 = extract_attr(trimmed, "r")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let g: u8 = extract_attr(trimmed, "g")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let b: u8 = extract_attr(trimmed, "b")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let color = FabricColor::rgb(r, g, b);
            if color_set_usage == "nodes" {
                brighter_colors.push((key, color));
            } else {
                darker_colors.push((key, color));
            }
            continue;
        }

        // Display options
        if trimmed.starts_with("<displayOptions ") || trimmed == "<displayOptions />" {
            if let Some(v) = extract_attr(trimmed, "nodeLight") {
                display.node_lighter_level = v.parse().unwrap_or(JAVA_DEFAULT_NODE_LIGHTER);
            }
            if let Some(v) = extract_attr(trimmed, "linkDark") {
                display.link_darker_level = v.parse().unwrap_or(JAVA_DEFAULT_LINK_DARKER);
            }
            if let Some(v) = extract_attr(trimmed, "minDrainZone") {
                display.min_drain_zone = v.parse().unwrap_or(JAVA_DEFAULT_MIN_DRAIN_ZONE);
            }
            if let Some(v) = extract_attr(trimmed, "shadows") {
                display.show_shadows = v == "true";
                display.shadows_explicit = true;
            }
            continue;
        }

        // Nodes section
        if trimmed == "<nodes>" {
            in_nodes = true;
            continue;
        }
        if trimmed == "</nodes>" {
            in_nodes = false;
            continue;
        }
        if in_nodes && trimmed.starts_with("<node ") {
            let name = xml_unescape(&extract_attr(trimmed, "name").unwrap_or_default());
            let nid: usize = extract_attr(trimmed, "nid")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let row: usize = extract_attr(trimmed, "row")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            // Java uses -1 for isolated nodes (no links).
            // Parse as isize first, then convert: -1 → usize::MAX (will be detected as isolated).
            let parse_col = |attr: &str| -> usize {
                let s = extract_attr(trimmed, attr).unwrap_or_default();
                match s.parse::<isize>() {
                    Ok(v) if v < 0 => usize::MAX,
                    Ok(v) => v as usize,
                    Err(_) => 0,
                }
            };
            let min_col = parse_col("minCol");
            let max_col = parse_col("maxCol");
            let min_col_sha = parse_col("minColSha");
            let max_col_sha = parse_col("maxColSha");
            let color_key = extract_attr(trimmed, "color").unwrap_or_default();

            // Find color index from key
            let color_index = GENE_COLOR_NAMES
                .iter()
                .position(|nc| nc.key == color_key)
                .unwrap_or(0);

            let node = ParsedNode {
                name,
                nid,
                row,
                min_col,
                max_col,
                min_col_sha,
                max_col_sha,
                color_index,
                color_key,
                plain_drain_zones: Vec::new(),
                shadow_drain_zones: Vec::new(),
            };

            if trimmed.ends_with("/>") {
                // Self-closing node (no drain zones)
                nid_to_name.insert(node.nid, node.name.clone());
                node_entries.push(node);
            } else {
                current_node = Some(node);
            }
            continue;
        }
        if trimmed == "</node>" {
            if let Some(node) = current_node.take() {
                nid_to_name.insert(node.nid, node.name.clone());
                node_entries.push(node);
            }
            continue;
        }

        // Drain zones
        if trimmed == "<drainZones>" {
            in_drain_zones = true;
            continue;
        }
        if trimmed == "</drainZones>" || trimmed == "<drainZones/>" {
            in_drain_zones = false;
            continue;
        }
        if trimmed == "<drainZonesShadow>" {
            in_drain_zones_shadow = true;
            continue;
        }
        if trimmed == "</drainZonesShadow>" || trimmed == "<drainZonesShadow/>" {
            in_drain_zones_shadow = false;
            continue;
        }
        if in_drain_zones && trimmed.starts_with("<drainZone ") {
            let min_c: usize = extract_attr(trimmed, "minCol")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let max_c: usize = extract_attr(trimmed, "maxCol")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            if let Some(ref mut node) = current_node {
                node.plain_drain_zones.push((min_c, max_c));
            }
            continue;
        }
        if in_drain_zones_shadow && trimmed.starts_with("<drainZoneShadow ") {
            let min_c: usize = extract_attr(trimmed, "minCol")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let max_c: usize = extract_attr(trimmed, "maxCol")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            if let Some(ref mut node) = current_node {
                node.shadow_drain_zones.push((min_c, max_c));
            }
            continue;
        }

        // Link groups
        if trimmed.starts_with("<linkGroups ") {
            in_link_groups = true;
            // Preserve mode text for roundtrip fidelity
            if let Some(mode) = extract_attr(trimmed, "mode") {
                layout.layout_mode_text = mode;
            }
            // Preserve annots flag
            if let Some(annots) = extract_attr(trimmed, "annots") {
                layout.link_group_annots = annots;
            }
            continue;
        }
        if trimmed == "</linkGroups>" {
            in_link_groups = false;
            continue;
        }
        if in_link_groups && trimmed.starts_with("<linkGroup ") {
            if let Some(tag) = extract_attr(trimmed, "tag") {
                layout.link_group_order.push(xml_unescape(&tag));
            }
            continue;
        }

        // Links section
        if trimmed == "<links>" {
            in_links = true;
            continue;
        }
        if trimmed == "</links>" {
            in_links = false;
            continue;
        }
        if in_links && trimmed.starts_with("<link ") {
            let src_nid: usize = extract_attr(trimmed, "srcID")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let trg_nid: usize = extract_attr(trimmed, "trgID")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let rel = xml_unescape(&extract_attr(trimmed, "rel").unwrap_or_default());
            let directed = extract_attr(trimmed, "directed")
                .map(|s| s == "true")
                .unwrap_or(false);
            let is_shadow = extract_attr(trimmed, "shadow")
                .map(|s| s == "true")
                .unwrap_or(false);
            let column: Option<usize> = extract_attr(trimmed, "column")
                .and_then(|s| s.parse().ok());
            let shadow_col: usize = extract_attr(trimmed, "shadowCol")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let src_row: usize = extract_attr(trimmed, "srcRow")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let trg_row: usize = extract_attr(trimmed, "trgRow")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let color_key = extract_attr(trimmed, "color").unwrap_or_default();

            let color_index = GENE_COLOR_NAMES
                .iter()
                .position(|nc| nc.key == color_key)
                .unwrap_or(0);

            link_entries.push(ParsedLink {
                src_nid,
                trg_nid,
                relation: rel,
                directed,
                is_shadow,
                column_no_shadows: column,
                shadow_col,
                src_row,
                trg_row,
                color_index,
            });
            continue;
        }

        // Annotation sections
        if trimmed == "<nodeAnnotations>" {
            in_node_annots = true;
            continue;
        }
        if trimmed == "</nodeAnnotations>" {
            in_node_annots = false;
            continue;
        }
        if trimmed == "<linkAnnotations>" {
            in_link_annots = true;
            continue;
        }
        if trimmed == "</linkAnnotations>" {
            in_link_annots = false;
            continue;
        }
        if trimmed == "<shadowLinkAnnotations>" {
            in_shadow_link_annots = true;
            continue;
        }
        if trimmed == "</shadowLinkAnnotations>" {
            in_shadow_link_annots = false;
            continue;
        }

        if (in_node_annots || in_link_annots || in_shadow_link_annots)
            && trimmed.starts_with("<annot ")
        {
            let tag = xml_unescape(&extract_attr(trimmed, "tag").unwrap_or_default());
            let start: usize = extract_attr(trimmed, "start")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let end: usize = extract_attr(trimmed, "end")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let layer: usize = extract_attr(trimmed, "layer")
                .unwrap_or_default()
                .parse()
                .unwrap_or(0);
            let color = extract_attr(trimmed, "color").unwrap_or_default();

            let annot = Annotation::new(tag, start, end, layer, color);

            if in_node_annots {
                layout.node_annotations.add(annot);
            } else if in_link_annots {
                // <linkAnnotations> = non-shadow column ranges (Java's linkAnnots_)
                layout.link_annotations_no_shadows.add(annot);
            } else {
                // <shadowLinkAnnotations> = shadow column ranges (Java's fullLinkAnnots_)
                layout.link_annotations.add(annot);
            }
            continue;
        }
    }

    // -- Reconstruct network and layout from parsed data --

    // Sort nodes by NID to get insertion order
    let mut sorted_nodes = node_entries.clone();
    sorted_nodes.sort_by_key(|n| n.nid);

    // Add nodes to network in NID order (preserving insertion order)
    for pn in &sorted_nodes {
        network.add_node(Node::new(pn.name.clone()));
    }

    // Add links to network
    // First, collect non-shadow links; then shadow links
    let mut non_shadow_links: Vec<&ParsedLink> = link_entries.iter().filter(|l| !l.is_shadow).collect();
    non_shadow_links.sort_by_key(|l| l.shadow_col);

    for pl in &non_shadow_links {
        let src_name = nid_to_name.get(&pl.src_nid).cloned().unwrap_or_default();
        let trg_name = nid_to_name.get(&pl.trg_nid).cloned().unwrap_or_default();
        let mut link = Link::new(src_name.clone(), trg_name.clone(), pl.relation.clone());
        link.directed = Some(pl.directed);
        network.add_link(link);
    }

    // Generate shadows (matching the way the original network was built)
    network.generate_shadows();

    // Build node layouts
    // Sort node_entries by row to build the layout
    let mut nodes_by_row = node_entries.clone();
    nodes_by_row.sort_by_key(|n| n.row);

    layout.row_count = nodes_by_row.len();

    for pn in &nodes_by_row {
        let mut nl = NodeLayout::new(pn.row, &pn.name);
        nl.min_col = pn.min_col_sha;
        nl.max_col = pn.max_col_sha;
        nl.min_col_no_shadows = pn.min_col;
        nl.max_col_no_shadows = pn.max_col;
        nl.color_index = pn.color_index;
        nl.nid = Some(pn.nid);
        layout.nodes.insert(NodeId::new(&pn.name), nl);
    }

    // Build link layouts from parsed links
    // Links are already sorted by shadow_col from the XML
    let mut all_parsed_links = link_entries;
    all_parsed_links.sort_by_key(|l| l.shadow_col);

    // Track column counts
    let mut max_shadow_col: usize = 0;
    let mut max_no_shadow_col: usize = 0;

    for pl in &all_parsed_links {
        let src_name = nid_to_name.get(&pl.src_nid).cloned().unwrap_or_default();
        let trg_name = nid_to_name.get(&pl.trg_nid).cloned().unwrap_or_default();

        // For shadow links: in Rust, shadows have flipped source/target
        let (ll_source, ll_target, ll_src_row, ll_trg_row) = if pl.is_shadow {
            (
                NodeId::new(&trg_name),
                NodeId::new(&src_name),
                pl.trg_row,
                pl.src_row,
            )
        } else {
            (
                NodeId::new(&src_name),
                NodeId::new(&trg_name),
                pl.src_row,
                pl.trg_row,
            )
        };

        let mut ll = LinkLayout::new(
            pl.shadow_col,
            ll_source,
            ll_target,
            ll_src_row,
            ll_trg_row,
            &pl.relation,
            pl.is_shadow,
        );
        ll.column_no_shadows = pl.column_no_shadows;
        ll.color_index = pl.color_index;
        ll.directed = if pl.directed { Some(true) } else { None };

        if pl.shadow_col > max_shadow_col {
            max_shadow_col = pl.shadow_col;
        }
        if let Some(ns) = pl.column_no_shadows {
            if ns > max_no_shadow_col {
                max_no_shadow_col = ns;
            }
        }

        layout.links.push(ll);
    }

    layout.column_count = if layout.links.is_empty() {
        0
    } else {
        max_shadow_col + 1
    };
    layout.column_count_no_shadows = if layout.links.iter().any(|l| l.column_no_shadows.is_some()) {
        max_no_shadow_col + 1
    } else {
        0
    };

    Ok(Session {
        network,
        layout: Some(layout),
        display_options: display,
        alignment_scores: None,
        metadata: super::session::SessionMetadata::default(),
        plugin_data_lines,
    })
}

/// Parsed node data from BIF XML.
#[derive(Debug, Clone)]
struct ParsedNode {
    name: String,
    nid: usize,
    row: usize,
    min_col: usize,
    max_col: usize,
    min_col_sha: usize,
    max_col_sha: usize,
    color_index: usize,
    color_key: String,
    plain_drain_zones: Vec<(usize, usize)>,
    shadow_drain_zones: Vec<(usize, usize)>,
}

/// Parsed link data from BIF XML.
#[derive(Debug, Clone)]
struct ParsedLink {
    src_nid: usize,
    trg_nid: usize,
    relation: String,
    directed: bool,
    is_shadow: bool,
    column_no_shadows: Option<usize>,
    shadow_col: usize,
    src_row: usize,
    trg_row: usize,
    color_index: usize,
}

/// Extract an attribute value from an XML element string.
///
/// e.g., `extract_attr("<node name=\"A\" row=\"0\">", "name")` → `Some("A")`
fn extract_attr(element: &str, attr_name: &str) -> Option<String> {
    // Look for: attr_name="value"
    let pattern = format!("{}=\"", attr_name);
    let start = element.find(&pattern)?;
    let value_start = start + pattern.len();
    let rest = &element[value_start..];
    let end = rest.find('"')?;
    Some(rest[..end].to_string())
}

/// Unescape XML entities.
fn xml_unescape(s: &str) -> String {
    s.replace("&amp;", "&")
        .replace("&lt;", "<")
        .replace("&gt;", ">")
        .replace("&quot;", "\"")
        .replace("&apos;", "'")
}
